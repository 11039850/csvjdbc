/* *  CsvJdbc - a JDBC driver for CSV files *  Copyright (C) 2008  Mario Frasca * *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */options{  STATIC = false;  LOOKAHEAD = 1;}PARSER_BEGIN(ExpressionParser)package org.relique.jdbc.csv;import java.util.Map;abstract class Expression{  public Object eval(Map env){    return null;  }}class NumericConstant extends Expression{  Number value;  public NumericConstant(Number d){    value = d;  }  public Object eval(Map env){    return value;  }  public String toString(){    return value.toString();  }}class StringConstant extends Expression{  String value;  public StringConstant(String s){    value = s;  }  public Object eval(Map env){    return value;  }  public String toString(){    return "'"+value+"'";  }}class ColumnSpecification extends Expression{  String fieldName;  Expression exp;  public ColumnSpecification(String fieldName){  	this .exp = null;    this .fieldName = fieldName.toUpperCase();  }  public ColumnSpecification(Expression exp, String fieldName){    this .exp = exp;    this .fieldName = fieldName.toUpperCase();  }  public Object eval(Map env){  	if (exp == null)      return env.get(fieldName);    return exp.eval(env);  }  public String toString(){    return "["+fieldName+"]";  }}class BinaryOperation extends Expression{  String op;  Expression left, right;  public BinaryOperation(String op, Expression left, Expression right){    this .op = op;    this .left = left;    this .right = right;  }  public Object eval(Map env){  	return null;  }  public String toString(){    return op+" "+left+" "+right;  }}abstract class LogicalExpression extends Expression{  public boolean isTrue(Map env){    return false;  }}class ParsedExpression extends LogicalExpression{  Expression content;  public ParsedExpression(Expression left){    content = left;  }  public boolean isTrue(Map env){    return ((LogicalExpression)content).isTrue(env);  }  public Object eval(Map env){    return content.eval(env);  }  public String toString(){    return content.toString();  }}class NotExpression extends LogicalExpression{  LogicalExpression arg;  public NotExpression(LogicalExpression arg){    this .arg = arg;  }  public boolean isTrue(Map env){    return !arg.isTrue(env);  }  public String toString(){    return "NOT "+arg;  }}class OrExpression extends LogicalExpression{  LogicalExpression left, right;  public OrExpression(LogicalExpression left, LogicalExpression right){    this .left = left;    this .right = right;  }  public boolean isTrue(Map env){    return left.isTrue(env) || right.isTrue(env);  }  public String toString(){    return "OR "+left+" "+right;  }}class AndExpression extends LogicalExpression{  LogicalExpression left, right;  public AndExpression(LogicalExpression left, LogicalExpression right){    this .left = left;    this .right = right;  }  public boolean isTrue(Map env){    return left.isTrue(env) && right.isTrue(env);  }  public String toString(){    return "AND "+left+" "+right;  }}class RelopExpression extends LogicalExpression{  String op;  Expression left, right;  public RelopExpression(String op, Expression left, Expression right){    this .op = op;    this .left = left;    this .right = right;  }  public boolean isTrue(Map env){    Comparable leftValue = (Comparable)left.eval(env);    Comparable rightValue = (Comparable)right.eval(env);    boolean result = false;    Integer leftComparedToRightObj = null;    try {      leftComparedToRightObj = new Integer(leftValue.compareTo(rightValue));    }    catch (ClassCastException e){}try {      Double leftDouble = new Double(((Number)leftValue).toString());      Double rightDouble = new Double(((Number)rightValue).toString());      leftComparedToRightObj = new Integer(leftDouble.compareTo(rightDouble));    }    catch (ClassCastException e){}catch (NumberFormatException e){}if (leftComparedToRightObj != null){      int leftComparedToRight = leftComparedToRightObj.intValue();      if (leftValue != null && rightValue != null){        if (op.equals("=")){          result = leftComparedToRight == 0;        }        else if (op.equals("<>") || op.equals("!=")){          result = leftComparedToRight != 0;        }        else if (op.equals(">")){          result = leftComparedToRight>0;        }        else if (op.equals("<")){          result = leftComparedToRight<0;        }        else if (op.equals("<=") || op.equals("=<")){          result = leftComparedToRight <= 0;        }        else if (op.equals(">=") || op.equals("=>")){          result = leftComparedToRight >= 0;        }      }    }    return result;  }  public String toString(){    return op+" "+left+" "+right;  }}class BetweenExpression extends LogicalExpression{  Expression obj, left, right;  public BetweenExpression(Expression obj, Expression left, Expression right){    this .obj = obj;    this .left = left;    this .right = right;  }  public boolean isTrue(Map env){    Comparable leftValue = (Comparable)left.eval(env);    Comparable rightValue = (Comparable)right.eval(env);    Comparable objValue = (Comparable)obj.eval(env);    boolean result = true;    try {      if (objValue.compareTo(leftValue)<0)result = false;      if (objValue.compareTo(rightValue)>0)result = false;    }    catch (ClassCastException e){}return result;  }  public String toString(){    return "B "+obj+" "+left+" "+right;  }}class IsNullExpression extends LogicalExpression{  Object arg;  public IsNullExpression(Object arg){    this .arg = arg;  }  public boolean isTrue(Map env){    if (env.get(arg) == null)return true;    return false;  }  public String toString(){    return "N "+arg;  }}class LikeExpression extends LogicalExpression{  Object arg1, arg2;  public LikeExpression(Object arg1, Object arg2){    this .arg1 = arg1;    this .arg2 = arg2;  }  public boolean isTrue(Map env){    return true;  }  public String toString(){    return "L "+arg1+" "+arg2;  }}public class ExpressionParser{  ParsedExpression content;  public void parseLogicalExpression()throws ParseException{    content = logicalExpression();  }  public void parseColumnSpecification()throws ParseException{    content = columnSpecification();  }  public boolean eval(Map env){    return content.isTrue(env);  }  public String toString(){    return ""+content;  }}PARSER_END(ExpressionParser)SKIP:{  " "  | "\t"  | "\n"}TOKEN:{  <NUMBER:<DIGITS>  | <DIGITS>"."<DIGITS>  | "."<DIGITS>  | <DIGITS>".">}TOKEN:{  <#DIGITS:(["0"-"9"])+>}TOKEN:{  <NULL:"NULL">}TOKEN:{  <AND:"AND">}TOKEN:{  <OR:"OR">}TOKEN:{  <NOT:"NOT">}TOKEN:{  <IS:"IS">}TOKEN:{  <AS:"AS">}TOKEN:{  <LIKE:"LIKE">}TOKEN:{  <BETWEEN:"BETWEEN">}TOKEN:{  <NAME:(["0"-"9", "A"-"Z", "a"-"z", "_"])+>}TOKEN:{  <STRING:"'"([" "-"&", "("-"~"])+"'">}TOKEN:{  <RELOP:(">"  | "<"  | ">="  | "<="  | "<>"  | "="  | "!=")>}TOKEN:{  <BINOP:("+"  | "-")>}ParsedExpression logicalExpression():{  LogicalExpression left;}{  left = logicalOrExpression()<EOF>{    return new ParsedExpression(left);  }}ParsedExpression columnSpecification():{  Expression value;  String alias;}{	{alias=null;}    value = binaryOperation()(<AS> alias=columnName())? <EOF>{    return new ParsedExpression(new ColumnSpecification(value, alias));  }}LogicalExpression logicalOrExpression():{  LogicalExpression left, right;}{  left = logicalAndExpression()(<OR>right = logicalAndExpression(){    left = new OrExpression(left, right);  }  )*{    return left;  }}LogicalExpression logicalAndExpression():{  LogicalExpression left, right;}{  left = logicalUnaryExpression()(<AND>right = logicalUnaryExpression(){    left = new AndExpression(left, right);  }  )*{    return left;  }}LogicalExpression logicalUnaryExpression():{  LogicalExpression arg;}{  <NOT>arg = logicalUnaryExpression(){    return new NotExpression(arg);  }  | "("arg = logicalOrExpression()")"{    return arg;  }  | arg = relationalExpression(){    return arg;  }}LogicalExpression relationalExpression():{  Expression arg1, arg2, arg3;  String op;  Token t;}{  arg1 = simpleExpression()(op = relOp()arg2 = simpleExpression(){    return new RelopExpression(op, arg1, arg2);  }  | <BETWEEN>arg2 = simpleExpression()<AND>arg3 = simpleExpression(){    return new BetweenExpression(arg1, arg2, arg3);  }  | <IS><NULL>{    return new IsNullExpression(arg1);  }  | <LIKE>t = <STRING>{    return new LikeExpression(arg1, new StringConstant(t.image.substring(1, t.image.length()-1)));  }  )}String relOp():{  Token t;}{  t = <RELOP>{    return new String(t.image);  }}String binOp():{  Token t;}{  t = <BINOP>{    return new String(t.image);  }}Expression binaryOperation():{	Expression left, right;	String op;}{	left=simpleExpression()(op=binOp() right=simpleExpression()	{		left=new BinaryOperation(op, left, right);	})*	{ return left; }}Expression simpleExpression():{  Expression arg;  String s;}{  s = columnName(){    return new ColumnSpecification(s);  }  | arg = numericConstant(){    return arg;  }  | arg = stringConstant(){  	return arg;  }  | <NULL>{    return null;  }}String columnName():{  Token t;}{  t = <NAME>{    return t.image;  }}Expression numericConstant():{  Token t;}{  t = <NUMBER>{    Number value = null;    try {      value = new Integer(t.image);    }    catch (NumberFormatException e){      value = new Double(t.image);    }    return new NumericConstant(value);  }}Expression stringConstant():{	String left, right;}{  left = stringConstantAtom()(right = stringConstantAtom(){    left = left + "'" + right;  }  )*{    return new StringConstant(left);  }}String stringConstantAtom():{	Token t;}{  t = <STRING>{    return t.image.substring(1, t.image.length()-1);  }}